{"meta":{"title":"ra4's blog","subtitle":"","description":"","author":"ra4","url":"https://ra4-z.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-07-29T08:34:23.569Z","updated":"2022-07-29T08:34:23.569Z","comments":false,"path":"books/index.html","permalink":"https://ra4-z.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-29T08:29:51.875Z","updated":"2022-07-29T08:29:51.874Z","comments":false,"path":"tags/index.html","permalink":"https://ra4-z.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-07-29T08:23:00.827Z","updated":"2022-07-29T08:23:00.826Z","comments":false,"path":"repository/index.html","permalink":"https://ra4-z.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-29T08:30:01.255Z","updated":"2022-07-29T08:30:01.255Z","comments":false,"path":"categories/index.html","permalink":"https://ra4-z.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-29T08:30:38.180Z","updated":"2022-07-29T08:30:38.180Z","comments":true,"path":"links/index.html","permalink":"https://ra4-z.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-29T08:30:31.286Z","updated":"2022-07-29T08:30:31.286Z","comments":false,"path":"about/index.html","permalink":"https://ra4-z.github.io/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"Design Pattern","slug":"Design-pattern","date":"2022-08-03T15:28:49.000Z","updated":"2022-08-03T16:07:39.378Z","comments":true,"path":"2022/08/03/Design-pattern/","link":"","permalink":"https://ra4-z.github.io/2022/08/03/Design-pattern/","excerpt":"","text":"单例模式 将构造函数、拷贝构造函数和赋值符号函数私有化 在类中定义一个静态的指向本类型的指针变量 定义一个返回值为类指针的静态成员函数12345678910111213141516class Singleton &#123;public: static Singleton * getInstance() &#123; if(nullptr == _pInstance) &#123; _pInstance = new Singleton(); &#125; return _pInstance; &#125; private: Singleton() &#123;&#125; Singleton(Singleton &amp;other)&#123;&#125; void operator=(const Singleton &amp;) &#123;&#125;private: Static Singleton * _pInstance;&#125;;Singleton * Singleton::_pInstance = nullptr; 这样会产生内存泄漏，没有释放的过程 123456789101112131415161718192021222324252627282930class Singleton&#123;private: static Singleton* instance;private: Singleton() &#123; &#125;; ~Singleton() &#123; &#125;; Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;);private: class Deletor &#123; public: ~Deletor() &#123; if(Singleton::instance != NULL) delete Singleton::instance; &#125; &#125;; static Deletor deletor;public: static Singleton* getInstance() &#123; if(instance == NULL) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125;;// init static memberSingleton* Singleton::instance = NULL;Singleton::Deletor Singleton::deletor; Reference: C++ 单例模式","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://ra4-z.github.io/tags/cpp/"}]},{"title":"c++_class","slug":"cpp-class","date":"2022-08-03T15:12:12.000Z","updated":"2022-08-03T16:07:37.062Z","comments":true,"path":"2022/08/03/cpp-class/","link":"","permalink":"https://ra4-z.github.io/2022/08/03/cpp-class/","excerpt":"","text":"class vs struct唯一的区别，就是默认访问权限不同。 class 的默认访问权限是private ， struct 的默认访问权限是 public 拷贝构造函数调用时机: 当把一个已经存在的对象赋值给另一个新对象时，会调用拷贝构造函数。 当实参和形参都是对象，进行实参与形参的结合时，会调用拷贝构造函数。 123456void f(A p);void main()&#123; A a; f(a);//a实参去初始化形参p，会调用copy构造函数&#125; 当函数的返回值是对象，函数调用完成返回时，会调用拷贝构造函数。 赋值运算函数默认情况下依然会采用浅拷贝的方式拷贝字符串。当两个对象被销毁时，同样会造成double free的问题，因此缺省赋值运算符函数不再满足需求，此时需要显式定义赋值运算符函数. 12345678910111213141516/* double freeComputer &amp; Computer::operator=(const Computer &amp; rhs)&#123; _brand = rhs._brand; _price = rhs._price; return *this;&#125;*/Computer &amp; Computer::operator=(const Computer &amp; rhs)&#123; if(this != &amp;rhs) &#123; delete [] _brand; _brand = new char[strlen(rhs._brand) + 1](); strcpy(_brand, rhs._brand); _price = rhs._price; &#125; return *this;&#125; 静态数据成员静态数据成员和静态变量一样，当程序执行时，该成员已经存在，一直到程序结束，任 何该类对象都可对其进行访问，静态数据成员存储在全局&#x2F;静态区，并不占据对象的存储空间。静态数据成员不属于类的任何一个对象，所以不能在类内部初始化静态数据成员，必须在类的外部定义和初始化静态数据成员。 静态成员函数静态成员函数的参数列表中不含有隐含的this指针，静态成员函数内部不能使用非静态的成员变量和非静态的成员函数,只能调用静态数据成员和静态的成员函数。 const成员函数 只能读取类数据成员，而不能修改之。 只能调用const成员函数，不能调用非const成员函数。","categories":[{"name":"cpp learning","slug":"cpp-learning","permalink":"https://ra4-z.github.io/categories/cpp-learning/"}],"tags":[]},{"title":"c++_memory","slug":"cpp-memory","date":"2022-08-03T15:03:36.000Z","updated":"2022-08-03T16:07:38.512Z","comments":true,"path":"2022/08/03/cpp-memory/","link":"","permalink":"https://ra4-z.github.io/2022/08/03/cpp-memory/","excerpt":"","text":"栈区(stack):由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区(heap):一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 全局&#x2F;静态区(static):全局变量和静态变量的存储是放在一块的，在程序编译时分配。 文字常量区:存放常量字符串。 程序代码区:存放函数体(类的成员函数、全局函数)的二进制代码","categories":[{"name":"cpp learning","slug":"cpp-learning","permalink":"https://ra4-z.github.io/categories/cpp-learning/"}],"tags":[]},{"title":"c++ = c + ?","slug":"c-vs-cpp","date":"2022-08-03T14:03:00.000Z","updated":"2022-08-03T15:04:01.521Z","comments":true,"path":"2022/08/03/c-vs-cpp/","link":"","permalink":"https://ra4-z.github.io/2022/08/03/c-vs-cpp/","excerpt":"","text":"namespaceconst!考点从右往左看法 const int * p; int const * p; int * const p; const int * const p;首先，4没有什么好说的。其他的都首先找到变量p，然后从右往左解析。看看1，p是一个指针，指向的是一个int，然后int是const的。即p是一个指向const int的指针。看看2，p是一个指针，指向一个const什么东西，然后发现const的是int。即p是一个指向const int的指针。看看3，p是一个const的什么东西，然后发现是const的指针，然后发现指向的是int。即p是一个指向int的const指针。看看4，其实不需要分析了，就是最严格的形式。 new&#x2F;delete！考点new&#x2F;delete表达式与malloc&#x2F;free的区别是？1）malloc&#x2F;free是C&#x2F;C++语言的标准库函数，new&#x2F;delete是C++的运算符或表达式 ；2）new能够自动分配空间大小，malloc需要传入参数； 3）new开辟空间的同时还对空间做了初始化的操作，而malloc不行；4）new&#x2F;delete能对对象进行构造和析构函数的调用，进而对内存进行更加详细的工 作，而malloc&#x2F;free不能。 引用&#x2F;别名强制转换static_cast: 一般转换 dynamic_cast:基类、派生类 const_cast: 常量指针&#x2F;常量引用&#x2F;常量对象，转换成非常量（且指向原来对象） reinterpret_cast:重新解释，随意转换 函数重载函数默认参数bool 类型inline 函数异常安全throw 12345double division(double x, double y)&#123; if(y == 0) throw &quot;Division by zero condition!&quot;;return x / y; &#125; try catch 12345678910void test() &#123; double x, y; cin &gt;&gt; x &gt;&gt; y; try &#123; if(y == 0) throw y; else cout &lt;&lt; (x / y) &lt;&lt; endl; &#125; catch(double d) &#123;cout &lt;&lt; &quot;catch(double)&quot; &lt;&lt; endl;","categories":[{"name":"cpp learning","slug":"cpp-learning","permalink":"https://ra4-z.github.io/categories/cpp-learning/"}],"tags":[]},{"title":"Hexo Glitches Fixing Recording","slug":"hexo-record","date":"2022-07-29T15:00:00.000Z","updated":"2022-08-03T16:07:41.251Z","comments":true,"path":"2022/07/29/hexo-record/","link":"","permalink":"https://ra4-z.github.io/2022/07/29/hexo-record/","excerpt":"","text":"图片由于路径问题无法显示图片无法通过插件（hexo-asset-image）默认使用方式显示，因为路径问题 解决：Hexo 无法加载图片（路径问题） pure主题无法直接显示category links等内容解决: 官方文档 取消显示侧边栏 toc 目录导航的序号解决：取消显示侧边栏 toc 目录导航的序号","categories":[{"name":"hexo","slug":"hexo","permalink":"https://ra4-z.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ra4-z.github.io/tags/hexo/"}]},{"title":"自用完美教程： ubuntu20.04 显卡驱动 CUDA CUDNN 依据官网安装","slug":"ubuntu_install","date":"2022-05-04T01:36:00.000Z","updated":"2022-07-29T15:19:35.956Z","comments":true,"path":"2022/05/04/ubuntu_install/","link":"","permalink":"https://ra4-z.github.io/2022/05/04/ubuntu_install/","excerpt":"","text":"0. 说明这是2022年5月4日成功安装nvidia driver&amp;cuda11.6&amp;cudnn的案例，仅供参考。每项包含安装和验证两个步骤，每个小标题都是对应的指导地址，请点击之。 我写了一些自动化安装的shell脚本，参见仓库ubuntu_init，欢迎取用。 1. NVIDIA Driver安装推荐510版本（对应cuda11.6） 验证能在命令行中使用nvidia-smi指令就成功了，如果不行可能是没有重启的原因 2. CUDA(CUDA Toolkit)安装主要是看nvidia-smi中的cuda版本，在官网列表中找到自己的版本，按机器的情况选择，就会得到完整的指令（runfile是图形界面，deb是命令行，个人推荐deb）参考官方教程 是deb方式的 验证进行安装成功验证如下： 1234567891011$ git clone --depth=1 https://github.com/NVIDIA/cuda-samples.git$ cd cuda-samples/Samples/1_Utilities/deviceQuery$ sudo make$ ./deviceQuery # 最后输出PASS就成功了./deviceQuery Starting... CUDA Device Query (Runtime API) version (CUDART static linking)........Result = PASS 似乎需要给.bashrc加内容，但我不清楚作用是什么。 12345678$ vim ~/.bashrc# 在最后加入以下两句，cuda版本号我是11.6，可能需要修改export PATH=/usr/local/cuda-11.6/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=/usr/local/cuda-11.6/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;# 最后$ source ~/.bashrc 3. CUDNN安装 Navigate to your directory containing the cuDNN Debian local installer file.下载 deb文件，登录拿qq、wechat就行 Enable the local repository.sudo dpkg -i cudnn-local-repo-$&#123;OS&#125;-8.x.x.x_1.0-1_amd64.deborsudo dpkg -i cudnn-local-repo-$&#123;OS&#125;-8.x.x.x_1.0-1_arm64.deb Import the CUDA GPG key.sudo apt-key add /var/cudnn-local-repo-*/7fa2af80.pub Refresh the repository metadata.sudo apt-get update 在这一步中，你会看到类似于Get:8 file:&#x2F;var&#x2F;cudnn-local-repo-ubuntu2004-8.4.0.27 Release [564 B]进入这个文件夹，里面是你能选的cudnn版本，也就是步骤5 6 7需要的版本号， Install the runtime library.sudo apt-get install libcudnn8=8.x.x.x-1+cudaX.Y Install the developer library.sudo apt-get install libcudnn8-dev=8.x.x.x-1+cudaX.Y Install the code samples and the cuDNN library documentation.sudo apt-get install libcudnn8-samples=8.x.x.x-1+cudaX.Y 验证 Copy the cuDNN samples to a writable path.cp -r /usr/src/cudnn_samples_v8/ $HOME Go to the writable path.cd $HOME/cudnn_samples_v8/mnistCUDNN Compile the mnistCUDNN sample.make clean &amp;&amp; make在这一步我显示了12345test.c:1:10: fatal error: FreeImage.h: No such file or directory 1 | #include &quot;FreeImage.h&quot; | ^~~~~~~~~~~~~compilation terminated.&gt;&gt;&gt; WARNING - FreeImage is not set up correctly. Please ensure FreeImage is set up correctly. &lt;&lt;&lt; 需要安装好FreeImage，参考12$ sudo apt-get install g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa libglu1-mesa-dev$ sudo apt-get install libfreeimage3 libfreeimage-dev Run the mnistCUDNN sample. ./mnistCUDNN如果没问题的话会显示：Test passed! 恭喜！到此已经完成安装！ 你已经拥有nvidia driver &amp; cuda11.6 &amp; cudnn8.4.0.27-1！ XD 其他Installing Google pinyin(搜狗输入法在Ubuntu下真是shit) 希望能帮到你 :)","categories":[{"name":"ubuntu_init","slug":"ubuntu-init","permalink":"https://ra4-z.github.io/categories/ubuntu-init/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ra4-z.github.io/tags/ubuntu/"},{"name":"driver","slug":"driver","permalink":"https://ra4-z.github.io/tags/driver/"},{"name":"cuda","slug":"cuda","permalink":"https://ra4-z.github.io/tags/cuda/"},{"name":"cudnn","slug":"cudnn","permalink":"https://ra4-z.github.io/tags/cudnn/"}]},{"title":"ssh服务增加端口的两个方法","slug":"ssh-add-port","date":"2021-08-12T09:39:00.000Z","updated":"2022-08-01T01:30:08.517Z","comments":true,"path":"2021/08/12/ssh-add-port/","link":"","permalink":"https://ra4-z.github.io/2021/08/12/ssh-add-port/","excerpt":"","text":"Method 1 sshd指令1sudo /usr/sbin/sshd -p 12345 这样就可以远程的时候使用12345端口进行连接了。 sshd是ssh的守护进程，上面这条指令实际上是使用一个进程来监控这个端口。 如果需要停掉这个连接的端口可以： 12ps -aux | grep sshdkill -9 &#123;porcess of sshd of your added port&#125; Method 2 修改sshd_config vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config添加如下一行： 1Port 929 重启ssh服务： 1/etc/init.d/ssh restart 查看ssh服务监听的端口是否为已设置端口： 1sudo netstat -tunlp | grep ssh 说明端口已经打开。可以用ssh进行连接测试，如果用该端口可以连接，则ok。否则可能是因为防火墙屏蔽了该端口，则需要防火墙打开该端口。 防火墙打开端口： 防火墙过滤规则中增加一条，允许对新增的端口929的访问： 1iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 929 -j ACCEPT 防火墙规则查看是否生效： 1iptables --list -n 查看端口是否生效。 保存 1service iptables save 参考sshd命令 – openssh服务器守护进程SSH服务相关知识linux ubuntu 修改ssh端口及常用命令一款短小精致的SSH后门分析","categories":[{"name":"net-tools","slug":"net-tools","permalink":"https://ra4-z.github.io/categories/net-tools/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://ra4-z.github.io/tags/ssh/"}]}],"categories":[{"name":"cpp learning","slug":"cpp-learning","permalink":"https://ra4-z.github.io/categories/cpp-learning/"},{"name":"hexo","slug":"hexo","permalink":"https://ra4-z.github.io/categories/hexo/"},{"name":"ubuntu_init","slug":"ubuntu-init","permalink":"https://ra4-z.github.io/categories/ubuntu-init/"},{"name":"net-tools","slug":"net-tools","permalink":"https://ra4-z.github.io/categories/net-tools/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://ra4-z.github.io/tags/cpp/"},{"name":"hexo","slug":"hexo","permalink":"https://ra4-z.github.io/tags/hexo/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://ra4-z.github.io/tags/ubuntu/"},{"name":"driver","slug":"driver","permalink":"https://ra4-z.github.io/tags/driver/"},{"name":"cuda","slug":"cuda","permalink":"https://ra4-z.github.io/tags/cuda/"},{"name":"cudnn","slug":"cudnn","permalink":"https://ra4-z.github.io/tags/cudnn/"},{"name":"ssh","slug":"ssh","permalink":"https://ra4-z.github.io/tags/ssh/"}]}