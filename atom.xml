<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ra4&#39;s blog</title>
  
  
  <link href="https://ra4-z.github.io/atom.xml" rel="self"/>
  
  <link href="https://ra4-z.github.io/"/>
  <updated>2022-08-03T16:31:25.996Z</updated>
  <id>https://ra4-z.github.io/</id>
  
  <author>
    <name>ra4</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cpp_IO_stream</title>
    <link href="https://ra4-z.github.io/2022/08/04/cpp-IO-stream/"/>
    <id>https://ra4-z.github.io/2022/08/04/cpp-IO-stream/</id>
    <published>2022-08-03T16:24:57.000Z</published>
    <updated>2022-08-03T16:31:25.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><ol><li>标准I&#x2F;O:键盘-&gt;屏幕</li><li>文件I&#x2F;O</li><li>字符串I&#x2F;O:字符串数组作为存储空间</li></ol><h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><ol><li>badbit 表示发生系统级的错误，如不可恢复的读写错误。通常情况下一旦 badbit 被置位，流就无法再使用了。</li><li>failbit 表示发生可恢复的错误，如期望读取一个数值，却读出一个字符等错误。这种问题通常是可以修改的，流还可以继续使用。 </li><li>当到达文件的结束位置时，eofbit 和 failbit 都会被置位。</li><li>goodbit 被置位表示流未发生错误。如果badbit、 failbit 和eofbit 任何 一个被置位，则检查流状态的条件会失。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//若流的badbit置位，则返回true;否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fail</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//若流的failbit或badbit置位，则返回true;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//若流的eofbit置位，则返回true;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">good</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//若流处于有效状态，则返回true;</span></span><br><span class="line"><span class="function">iostate <span class="title">rdstate</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获取流的状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setstate</span><span class="params">(iostate state)</span></span>; <span class="comment">//设置流的状态</span></span><br><span class="line"><span class="comment">//clear的无参版本会复位所有错误标志位*(重置流的状态)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(std::ios_base::iostate state = std::ios_base::goodbit)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;标准I&amp;#x2F;O:键盘-&amp;gt;屏幕&lt;/li&gt;
&lt;li&gt;文件I&amp;#x2F;O&lt;/li&gt;
&lt;li&gt;字符串I&amp;#x2F;O:字符</summary>
      
    
    
    
    <category term="cpp learning" scheme="https://ra4-z.github.io/categories/cpp-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Design Pattern</title>
    <link href="https://ra4-z.github.io/2022/08/03/Design-pattern/"/>
    <id>https://ra4-z.github.io/2022/08/03/Design-pattern/</id>
    <published>2022-08-03T15:28:49.000Z</published>
    <updated>2022-08-04T02:56:42.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ol><li>将构造函数、拷贝构造函数和赋值符号函数私有化</li><li>在类中定义一个静态的指向本类型的指针变量 </li><li>定义一个返回值为类指针的静态成员函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == _pInstance)</span><br><span class="line">            &#123; _pInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); &#125;</span><br><span class="line">        <span class="keyword">return</span> _pInstance;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_pInstance)</span><br><span class="line">            <span class="keyword">delete</span> _pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;other)&#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Static Singleton * _pInstance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton * Singleton::_pInstance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li></ol><p>这样不是自动释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> Singleton* instance;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>() &#123; &#125;;</span><br><span class="line">~<span class="built_in">Singleton</span>() &#123; &#125;;</span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deletor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Deletor</span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(Singleton::instance != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">delete</span> Singleton::instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> Deletor deletor;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init static member</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton::Deletor Singleton::deletor;</span><br></pre></td></tr></table></figure><p>Reference: <a href="https://zhuanlan.zhihu.com/p/37469260">C++ 单例模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;将构造函数、拷贝构造函数和赋值符号函数私有化&lt;/li&gt;
&lt;li&gt;在类中定义一个静态的指向本类型的指针变量 &lt;/l</summary>
      
    
    
    
    <category term="cpp learning" scheme="https://ra4-z.github.io/categories/cpp-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>c++_class</title>
    <link href="https://ra4-z.github.io/2022/08/03/cpp-class/"/>
    <id>https://ra4-z.github.io/2022/08/03/cpp-class/</id>
    <published>2022-08-03T15:12:12.000Z</published>
    <updated>2022-08-03T16:07:37.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="class-vs-struct"><a href="#class-vs-struct" class="headerlink" title="class vs struct"></a>class vs struct</h1><p>唯一的区别，就是默认访问权限不同。 <code>class</code> 的默认访问权限是<code>private</code> ， <code>struct</code> 的默认访问权限是 <code>public</code></p><h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>调用时机:</p><ol><li><p>当把一个已经存在的对象赋值给另一个新对象时，会调用拷贝构造函数。</p></li><li><p>当实参和形参都是对象，进行实参与形参的结合时，会调用拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">f</span>(a);<span class="comment">//a实参去初始化形参p，会调用copy构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当函数的返回值是对象，函数调用完成返回时，会调用拷贝构造函数。</p></li></ol><h1 id="赋值运算函数"><a href="#赋值运算函数" class="headerlink" title="赋值运算函数"></a>赋值运算函数</h1><p>默认情况下依然会采用浅拷贝的方式拷贝字符串。当两个对象被销毁时，同样会造成<code>double free</code>的问题，因此缺省赋值运算符函数不再满足需求，此时需要显式定义赋值运算符函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* double free</span></span><br><span class="line"><span class="comment">Computer &amp; Computer::operator=(const Computer &amp; rhs)&#123;</span></span><br><span class="line"><span class="comment">    _brand = rhs._brand;</span></span><br><span class="line"><span class="comment">    _price = rhs._price;</span></span><br><span class="line"><span class="comment">    return *this;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Computer &amp; Computer::<span class="keyword">operator</span>=(<span class="type">const</span> Computer &amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _brand;</span><br><span class="line">        _brand = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(rhs._brand) + <span class="number">1</span>]();</span><br><span class="line">        <span class="built_in">strcpy</span>(_brand, rhs._brand);</span><br><span class="line">        _price = rhs._price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h1><p>静态数据成员和静态变量一样，当程序执行时，该成员已经存在，一直到程序结束，任 何该类对象都可对其进行访问，静态数据成员存储在全局&#x2F;静态区，并不占据对象的存储空间。<br>静态数据成员不属于类的任何一个对象，所以不能在类内部初始化静态数据成员，必须在类的外部定义和初始化静态数据成员。</p><h1 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h1><p>静态成员函数的参数列表中不含有隐含的<code>this</code>指针，静态成员函数内部不能使用非静态的成员变量和非静态的成员函数,只能调用静态数据成员和静态的成员函数。</p><h1 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a><code>const</code>成员函数</h1><ol><li>只能读取类数据成员，而不能修改之。</li><li>只能调用const成员函数，不能调用非const成员函数。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;class-vs-struct&quot;&gt;&lt;a href=&quot;#class-vs-struct&quot; class=&quot;headerlink&quot; title=&quot;class vs struct&quot;&gt;&lt;/a&gt;class vs struct&lt;/h1&gt;&lt;p&gt;唯一的区别，就是默认访问权限不同。 </summary>
      
    
    
    
    <category term="cpp learning" scheme="https://ra4-z.github.io/categories/cpp-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>c++_memory</title>
    <link href="https://ra4-z.github.io/2022/08/03/cpp-memory/"/>
    <id>https://ra4-z.github.io/2022/08/03/cpp-memory/</id>
    <published>2022-08-03T15:03:36.000Z</published>
    <updated>2022-08-03T16:26:00.153Z</updated>
    
    <content type="html"><![CDATA[<ol><li>栈区(stack):由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区(heap):一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li><li>全局&#x2F;静态区(static):全局变量和静态变量的存储是放在一块的，在程序编译时分配。</li><li>文字常量区:存放常量字符串。</li><li>程序代码区:存放函数体(类的成员函数、全局函数)的二进制代码</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;栈区(stack):由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。&lt;/li&gt;
&lt;li&gt;堆区(heap):一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链</summary>
      
    
    
    
    <category term="cpp learning" scheme="https://ra4-z.github.io/categories/cpp-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>c++ = c + ?</title>
    <link href="https://ra4-z.github.io/2022/08/03/c-vs-cpp/"/>
    <id>https://ra4-z.github.io/2022/08/03/c-vs-cpp/</id>
    <published>2022-08-03T14:03:00.000Z</published>
    <updated>2022-08-03T15:04:01.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>!考点<br><a href="https://www.zhihu.com/question/31044695/answer/51839777">从右往左看法</a></p><ol><li>const int * p;</li><li>int const * p;</li><li>int * const p;</li><li>const int * const p;<br>首先，4没有什么好说的。其他的都首先找到变量p，然后从右往左解析。看看1，p是一个指针，指向的是一个int，然后int是const的。即p是一个指向const int的指针。看看2，p是一个指针，指向一个const什么东西，然后发现const的是int。即p是一个指向const int的指针。看看3，p是一个const的什么东西，然后发现是const的指针，然后发现指向的是int。即p是一个指向int的const指针。看看4，其实不需要分析了，就是最严格的形式。</li></ol><h1 id="new-x2F-delete"><a href="#new-x2F-delete" class="headerlink" title="new&#x2F;delete"></a>new&#x2F;delete</h1><p>！考点<br>new&#x2F;delete表达式与malloc&#x2F;free的区别是？<br>1）malloc&#x2F;free是C&#x2F;C++语言的标准库函数，new&#x2F;delete是C++的运算符或表达式 ；<br>2）new能够自动分配空间大小，malloc需要传入参数； 3）new开辟空间的同时还对空间做了初始化的操作，而malloc不行；<br>4）new&#x2F;delete能对对象进行构造和析构函数的调用，进而对内存进行更加详细的工 作，而malloc&#x2F;free不能。</p><h1 id="引用-x2F-别名"><a href="#引用-x2F-别名" class="headerlink" title="引用&#x2F;别名"></a>引用&#x2F;别名</h1><h1 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h1><p>static_cast: 一般转换</p><p>dynamic_cast:基类、派生类</p><p>const_cast: 常量指针&#x2F;常量引用&#x2F;常量对象，转换成非常量（且指向原来对象）</p><p>reinterpret_cast:重新解释，随意转换</p><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h1 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h1><h1 id="bool-类型"><a href="#bool-类型" class="headerlink" title="bool 类型"></a>bool 类型</h1><h1 id="inline-函数"><a href="#inline-函数" class="headerlink" title="inline 函数"></a>inline 函数</h1><h1 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h1><p><code>throw</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> x / y; &#125;</span><br></pre></td></tr></table></figure><p><code>try catch</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; (x / y) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">double</span> d) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch(double)&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;namespace&quot;&gt;&lt;a href=&quot;#namespace&quot; class=&quot;headerlink&quot; title=&quot;namespace&quot;&gt;&lt;/a&gt;namespace&lt;/h1&gt;&lt;h1 id=&quot;const&quot;&gt;&lt;a href=&quot;#const&quot; class=&quot;header</summary>
      
    
    
    
    <category term="cpp learning" scheme="https://ra4-z.github.io/categories/cpp-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo Glitches Fixing Recording</title>
    <link href="https://ra4-z.github.io/2022/07/29/hexo-record/"/>
    <id>https://ra4-z.github.io/2022/07/29/hexo-record/</id>
    <published>2022-07-29T15:00:00.000Z</published>
    <updated>2022-08-03T16:07:41.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图片由于路径问题无法显示"><a href="#图片由于路径问题无法显示" class="headerlink" title="图片由于路径问题无法显示"></a>图片由于路径问题无法显示</h1><p>图片无法通过插件（<code>hexo-asset-image</code>）默认使用方式显示，因为路径问题</p><p>解决：<br><a href="https://yonahwang.github.io/2019/08/30/web-bugs/hexo-add-picture/#:~:text=hexo%E9%BB%98%E8%AE%A4%E6%97%A0%E6%B3%95,%E8%BF%87%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E6%94%AF%E6%8C%81%E3%80%82">Hexo 无法加载图片（路径问题）</a></p><h1 id="pure主题无法直接显示category-links等内容"><a href="#pure主题无法直接显示category-links等内容" class="headerlink" title="pure主题无法直接显示category links等内容"></a>pure主题无法直接显示<code>category</code> <code>links</code>等内容</h1><p>解决: <a href="https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md#%E9%A1%B9%E7%9B%AE">官方文档</a></p><h1 id="取消显示侧边栏-toc-目录导航的序号"><a href="#取消显示侧边栏-toc-目录导航的序号" class="headerlink" title="取消显示侧边栏 toc 目录导航的序号"></a>取消显示侧边栏 toc 目录导航的序号</h1><p>解决：<br><a href="https://github.com/cofess/hexo-theme-pure/issues/154">取消显示侧边栏 toc 目录导航的序号</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图片由于路径问题无法显示&quot;&gt;&lt;a href=&quot;#图片由于路径问题无法显示&quot; class=&quot;headerlink&quot; title=&quot;图片由于路径问题无法显示&quot;&gt;&lt;/a&gt;图片由于路径问题无法显示&lt;/h1&gt;&lt;p&gt;图片无法通过插件（&lt;code&gt;hexo-asset-imag</summary>
      
    
    
    
    <category term="hexo" scheme="https://ra4-z.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://ra4-z.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>TODO</title>
    <link href="https://ra4-z.github.io/2022/07/25/TODO/"/>
    <id>https://ra4-z.github.io/2022/07/25/TODO/</id>
    <published>2022-07-24T17:56:07.000Z</published>
    <updated>2022-08-04T06:50:11.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a>TODO:</h1><ul><li><input disabled type="checkbox"> 域名  </li><li><input checked disabled type="checkbox"> <a href="https://titangene.github.io/article/hexo-disqus.html">Hexo 加入 Disqus 留言版 (包含留言數)</a></li><li><input checked disabled type="checkbox"> <a href="https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md">pure使用指南</a></li><li><input disabled type="checkbox"> Icarus补充内容</li><li><input disabled type="checkbox"> 搬运gitpages到github</li><li><input disabled type="checkbox"> 搬运segmentfault到gitpages</li></ul><h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions:"></a>Questions:</h1><p>Pure主题下，Categories和Tags都没有自动生成index.html文件。怎么办？<br>About也是。为啥像tags.md那样就能有效果？？</p><p><code>public/archives/</code>里有个index.html文件，但<code>public/categorys/</code>和<code>public/tags/</code>没有。</p><h1 id="Refenrences"><a href="#Refenrences" class="headerlink" title="Refenrences:"></a>Refenrences:</h1><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="https://hexo.io/zh-cn/">Hexo doc</a></p><h2 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h2><p><a href="https://ppoffice.github.io/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Icarus快速上手</a></p><p><a href="https://github.com/theme-next/hexo-theme-next">next theme</a></p><p><a href="https://github.com/blinkfox/hexo-theme-matery">blink fox</a></p><p><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO:&quot;&gt;&lt;/a&gt;TODO:&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;input disabled type=&quot;checkbox&quot;&gt; 域名  &lt;/li&gt;
&lt;li&gt;&lt;input </summary>
      
    
    
    
    <category term="TODO" scheme="https://ra4-z.github.io/categories/TODO/"/>
    
    <category term="test" scheme="https://ra4-z.github.io/categories/TODO/test/"/>
    
    
    <category term="TODO" scheme="https://ra4-z.github.io/tags/TODO/"/>
    
  </entry>
  
  <entry>
    <title>自用完美教程： ubuntu20.04 显卡驱动 CUDA CUDNN 依据官网安装</title>
    <link href="https://ra4-z.github.io/2022/05/04/ubuntu_install/"/>
    <id>https://ra4-z.github.io/2022/05/04/ubuntu_install/</id>
    <published>2022-05-04T01:36:00.000Z</published>
    <updated>2022-07-29T15:19:35.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h1><p>这是2022年5月4日成功安装<code>nvidia driver</code>&amp;<code>cuda11.6</code>&amp;<code>cudnn</code>的案例，仅供参考。<br>每项包含<strong>安装</strong>和<strong>验证</strong>两个步骤，每个小标题都是对应的指导地址，请点击之。</p><p>我写了一些自动化安装的shell脚本，参见仓库<a href="https://github.com/ra4-z/ubuntu_init">ubuntu_init</a>，欢迎取用。</p><h1 id="1-NVIDIA-Driver"><a href="#1-NVIDIA-Driver" class="headerlink" title="1. NVIDIA Driver"></a>1. NVIDIA Driver</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://www.linuxcapable.com/zh_cn/%e5%a6%82%e4%bd%95%e5%ae%89%e8%a3%85-nvidia-drivers-on-ubuntu-22-04-lts/">安装</a></h2><p>推荐510版本（对应cuda11.6）</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>能在命令行中使用<code>nvidia-smi</code>指令就成功了，如果不行可能是没有重启的原因</p><h1 id="2-CUDA-CUDA-Toolkit"><a href="#2-CUDA-CUDA-Toolkit" class="headerlink" title="2. CUDA(CUDA Toolkit)"></a>2. CUDA(CUDA Toolkit)</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#ubuntu-installation">安装</a></h2><p>主要是看<code>nvidia-smi</code>中的cuda版本，在<a href="https://developer.nvidia.com/cuda-toolkit-archive">官网</a>列表中找到自己的版本，按机器的情况选择，就会得到<strong>完整的指令</strong>（runfile是图形界面，deb是命令行，个人推荐deb）<br><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#ubuntu-installation">参考官方教程</a> 是deb方式的</p><h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a><a href="https://github.com/NVIDIA/cuda-samples.git">验证</a></h2><p>进行安装成功验证如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/NVIDIA/cuda-samples.git</span><br><span class="line">$ cd cuda-samples/Samples/1_Utilities/deviceQuery</span><br><span class="line">$ sudo make</span><br><span class="line">$ ./deviceQuery </span><br><span class="line"># 最后输出PASS就成功了</span><br><span class="line">./deviceQuery Starting...</span><br><span class="line"></span><br><span class="line"> CUDA Device Query (Runtime API) version (CUDART static linking)</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">Result = PASS</span><br></pre></td></tr></table></figure><p>似乎需要给.bashrc加内容，但我不清楚作用是什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"># 在最后加入以下两句，cuda版本号我是11.6，可能需要修改</span><br><span class="line">export PATH=/usr/local/cuda-11.6/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-11.6/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 最后</span><br><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="3-CUDNN"><a href="#3-CUDNN" class="headerlink" title="3. CUDNN"></a>3. CUDNN</h1><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a><a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#installlinux-deb">安装</a></h2><ol><li>Navigate to your <cudnnpath> directory containing the cuDNN Debian local installer file.<br><a href="https://developer.nvidia.com/rdp/cudnn-download">下载</a> deb文件，登录拿qq、wechat就行</cudnnpath></li><li>Enable the local repository.<br><code>sudo dpkg -i cudnn-local-repo-$&#123;OS&#125;-8.x.x.x_1.0-1_amd64.deb</code><br>or<br><code>sudo dpkg -i cudnn-local-repo-$&#123;OS&#125;-8.x.x.x_1.0-1_arm64.deb</code></li><li>Import the CUDA GPG key.<br><code>sudo apt-key add /var/cudnn-local-repo-*/7fa2af80.pub</code></li><li>Refresh the repository metadata.<br><code>sudo apt-get update</code><blockquote><p>在这一步中，你会看到类似于Get:8 file:&#x2F;var&#x2F;cudnn-local-repo-ubuntu2004-8.4.0.27  Release [564 B]<br>进入这个文件夹，里面是你能选的cudnn版本，也就是步骤5 6 7需要的版本号，</p></blockquote></li><li>Install the runtime library.<br><code>sudo apt-get install libcudnn8=8.x.x.x-1+cudaX.Y</code></li><li>Install the developer library.<br><code>sudo apt-get install libcudnn8-dev=8.x.x.x-1+cudaX.Y</code></li><li>Install the code samples and the cuDNN library documentation.<br><code>sudo apt-get install libcudnn8-samples=8.x.x.x-1+cudaX.Y</code></li></ol><h2 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a><a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#verify">验证</a></h2><ol><li>Copy the cuDNN samples to a writable path.<br><code>cp -r /usr/src/cudnn_samples_v8/ $HOME</code></li><li>Go to the writable path.<br><code>cd  $HOME/cudnn_samples_v8/mnistCUDNN</code></li><li>Compile the mnistCUDNN sample.<br><code>make clean &amp;&amp; make</code><br>在这一步我显示了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test.c:1:10: fatal error: FreeImage.h: No such file or directory</span><br><span class="line">    1 | #include &quot;FreeImage.h&quot;</span><br><span class="line">      |          ^~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">&gt;&gt;&gt; WARNING - FreeImage is not set up correctly. Please ensure FreeImage is set up correctly. &lt;&lt;&lt;</span><br></pre></td></tr></table></figure> 需要安装好<code>FreeImage</code>，<a href="https://forums.developer.nvidia.com/t/freeimage-is-not-set-up-correctly-please-ensure-freeimae-is-set-up-correctly/66950/2?u=466178965">参考</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa libglu1-mesa-dev</span><br><span class="line">$ sudo apt-get install libfreeimage3 libfreeimage-dev</span><br></pre></td></tr></table></figure></li><li>Run the mnistCUDNN sample.<br><code> ./mnistCUDNN</code><br>如果没问题的话会显示：<br>Test passed!</li></ol><p>恭喜！到此已经完成安装！ 你已经拥有<code>nvidia driver</code> &amp; <code>cuda11.6</code> &amp; <code>cudnn8.4.0.27-1</code>！ XD</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.cnblogs.com/it-Ren/p/15566581.html">Installing Google pinyin</a><br>(搜狗输入法在Ubuntu下真是shit)</p><p><font size="5">希望能帮到你 :)</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-说明&quot;&gt;&lt;a href=&quot;#0-说明&quot; class=&quot;headerlink&quot; title=&quot;0. 说明&quot;&gt;&lt;/a&gt;0. 说明&lt;/h1&gt;&lt;p&gt;这是2022年5月4日成功安装&lt;code&gt;nvidia driver&lt;/code&gt;&amp;amp;&lt;code&gt;cuda11.6</summary>
      
    
    
    
    <category term="ubuntu_init" scheme="https://ra4-z.github.io/categories/ubuntu-init/"/>
    
    
    <category term="ubuntu" scheme="https://ra4-z.github.io/tags/ubuntu/"/>
    
    <category term="driver" scheme="https://ra4-z.github.io/tags/driver/"/>
    
    <category term="cuda" scheme="https://ra4-z.github.io/tags/cuda/"/>
    
    <category term="cudnn" scheme="https://ra4-z.github.io/tags/cudnn/"/>
    
  </entry>
  
  <entry>
    <title>ssh服务增加端口的两个方法</title>
    <link href="https://ra4-z.github.io/2021/08/12/ssh-add-port/"/>
    <id>https://ra4-z.github.io/2021/08/12/ssh-add-port/</id>
    <published>2021-08-12T09:39:00.000Z</published>
    <updated>2022-08-01T01:30:08.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Method-1-sshd指令"><a href="#Method-1-sshd指令" class="headerlink" title="Method 1 sshd指令"></a>Method 1 sshd指令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/sbin/sshd -p 12345</span><br></pre></td></tr></table></figure><p>这样就可以远程的时候使用12345端口进行连接了。</p><p>sshd是ssh的守护进程，上面这条指令实际上是使用一个进程来监控这个端口。</p><p>如果需要停掉这个连接的端口可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep sshd</span><br><span class="line"><span class="built_in">kill</span> -9 &#123;porcess of sshd of your added port&#125;</span><br></pre></td></tr></table></figure><h1 id="Method-2-修改sshd-config"><a href="#Method-2-修改sshd-config" class="headerlink" title="Method 2 修改sshd_config"></a>Method 2 修改sshd_config</h1><ol><li><p>vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config添加如下一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 929</span><br></pre></td></tr></table></figure></li><li><p>重启ssh服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure></li><li><p>查看ssh服务监听的端口是否为已设置端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tunlp | grep ssh</span><br></pre></td></tr></table></figure><p><img src="/2021/08/12/ssh-add-port/pic.jpg" alt="pic"><br>说明端口已经打开。可以用ssh进行连接测试，如果用该端口可以连接，则ok。否则可能是因为防火墙屏蔽了该端口，则需要防火墙打开该端口。</p></li></ol><p>防火墙打开端口：</p><ol><li><p>防火墙过滤规则中增加一条，允许对新增的端口929的访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 929 -j ACCEPT</span><br></pre></td></tr></table></figure></li><li><p>防火墙规则查看是否生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables --list -n 查看端口是否生效。</span><br></pre></td></tr></table></figure></li><li><p>保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables save</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.linuxcool.com/sshd">sshd命令 – openssh服务器守护进程</a><br><a href="https://www.huaweicloud.com/articles/3cc874da0de5494dbf1e895c5a98f67f.html">SSH服务相关知识</a><br><a href="https://blog.csdn.net/sinat_29891353/article/details/87460790">linux ubuntu 修改ssh端口及常用命令</a><br><a href="https://cloud.tencent.com/developer/article/1047301">一款短小精致的SSH后门分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Method-1-sshd指令&quot;&gt;&lt;a href=&quot;#Method-1-sshd指令&quot; class=&quot;headerlink&quot; title=&quot;Method 1 sshd指令&quot;&gt;&lt;/a&gt;Method 1 sshd指令&lt;/h1&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="net-tools" scheme="https://ra4-z.github.io/categories/net-tools/"/>
    
    
    <category term="ssh" scheme="https://ra4-z.github.io/tags/ssh/"/>
    
  </entry>
  
</feed>
